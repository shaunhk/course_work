MVP Questions

In our Property Tracker application:

Q1. Where are we instantiating instances of the Property class?

A1: console.rb

Q2. Where are we defining the SQL that enables us to save the ruby Property object into the database?

In the property.rb file in models folder.

Q3. In console.rb, which lines modify the database?

The lines calling functions on the Property instances.

Q4. Why do we not define the id of a Property object at the point we instantiate it (‘new it up’)?

Becasue we want a large database to automatically generate them, it's simpler and faster.

Q5. Where and how do we assign the id (that is generated by the database) to the ruby Property object?

assign in property.rb under def initialize with @id = options['id'].to_i() if options['id']

Q6. Why do we put a guard (an if clause) on the @id attribute in the constructor?

Because we don't want ids being used to create new fields or to provide sql injection attacks.

Q7. Why are some of the CRUD actions represented by instance methods, and others by class methods?

Class methods affect all instances while instance methods are used to alter one specific instance.

Q8. What type of data structure is returned by calls to db.exec_prepared()? In the save method, how do we access the id from the returned data structure?

An array - PG object, it is accessed by the assigning of a global variable.

Q9. Why do we use prepared statements when performing database operations?

To sanitise our code. It stops it being accessed outside the function.

Extension Questions

Look at the find_by_id and find_by_address methods in the Property class.

Q10. What do they take in as their arguments?

id and address respectively.

Q11. What are their return values?

They return the found property as a hash.aa
